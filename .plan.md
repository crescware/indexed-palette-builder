# OKLCH Mode Toggle GUI - Implementation Plan

## Objective

Add a color format toggle that allows switching between "hex" and "oklch" display modes. This phase implements only the toggle GUI and internal state management - no changes to color display yet.

## Design Consideration: Toggle Placement

The color format preference is a **core user preference** that affects the primary output of the application. Unlike secondary settings (theme, edge shades visibility), this should be easily accessible without opening a settings popup.

### Scope of the Toggle

The color format affects **two distinct areas**:

1. **Left side (PaletteBuilder)**: Swatch tooltips display color values
2. **Right side (CssExport)**: CSS variable output in the textarea

This means the toggle must be placed in a position that clearly implies **global scope** - affecting both areas.

### Placement Options

#### Option A: Inline with CSS Export - NOT RECOMMENDED

```
CSS Variables    [HEX|OKLCH]    [Copy]
```

**Why unsuitable**: Placement next to CSS output implies the toggle only affects CSS export. Users would not expect swatch tooltips on the left to change.

#### Option B: Header Area (Recommended)

Place a toggle button group in the header next to Edit/Settings buttons:

```
Indexed Palette Builder          [HEX|OKLCH] [Edit] [Settings]
```

**Pros:**
- Positioned above both palette and CSS export - implies global scope
- Always visible regardless of scroll position
- No additional vertical space required

**Cons:**
- Adds visual complexity to header

#### Option C: Toolbar Row

Add a toolbar row between header and main content:

```
Header
-----------------------------------
Color Format: [HEX|OKLCH]
-----------------------------------
Palette swatches...    |  CSS export...
```

**Pros:**
- Clear visibility and separation from header controls
- Room for future toolbar additions
- Positioned above both areas - implies global scope

**Cons:**
- Adds vertical space
- May feel like over-engineering for a single toggle

### Recommendation

**Option B (Header)** is recommended because:
- It clearly communicates global scope without using extra vertical space
- The toggle is always visible
- Consistent with modern UI patterns where format/view toggles appear in headers

---

## Color Format Type

### Current Scope

```typescript
type ColorFormat = "hex" | "oklch";
```

Default value: `"hex"`

### Future Scope (Out of Scope for This Phase)

The type should be designed to accommodate future expansion:

```typescript
type ColorFormat =
  | "hex"        // #ff0000
  | "hexa"       // #ff0000ff
  | "rgb"        // rgb(255, 0, 0)
  | "rgba"       // rgba(255, 0, 0, 1)
  | "oklch";     // oklch(0.628 0.258 29.2)
```

### UI Implication

A segmented button (`[HEX|OKLCH]`) works for 2 options but does not scale to 5+ options.

**Recommendation**: Use a **dropdown/select** instead of a segmented button. This:
- Scales to any number of format options
- Takes less horizontal space in the header
- Is familiar UI pattern for format selection

```
Indexed Palette Builder          [HEX v] [Edit] [Settings]
```

When expanded:
```
                                 +--------+
                                 | HEX    | <-- selected
                                 | OKLCH  |
                                 +--------+
```

## Implementation Progress

### Completed

- [x] **Step 10**: Create state type (`src/models/color-format-state.ts`)
- [x] **Step 20**: Add storage key (`src/models/storage/storage.ts`)
- [x] **Step 30**: Create context provider (`src/contexts/color-format/color-format-context.tsx`)
- [x] **Step 35**: Create hook (`src/contexts/color-format/use-color-format.ts`)
- [x] **Step 40**: Register provider (`src/app.tsx`)
- [x] **Step 50**: Create format selector component (`src/components/color-format-select.tsx`)
- [x] **Step 60**: Place selector in header (`src/components/header.tsx`)
- [x] **Step 70**: Update `settings-popup.tsx` to call `resetColorFormat()`
- [x] Visual styling finalized (borderless, ChevronDown icon from lucide-solid)
- [x] Edit/Done button width stabilized with `min-w-16`

### Why Context is Required

The color format state needs to be shared across multiple components:

| Component | Usage |
|-----------|-------|
| `color-format-select.tsx` | Read and write the current format |
| `settings-popup.tsx` | Reset format on "Reset all data" |
| `color-palette.tsx` | Display tooltips in selected format (future) |
| `css-export.tsx` | Output CSS variables in selected format (future) |

A local signal in `color-format-select.tsx` cannot be accessed by `settings-popup.tsx` for reset.
Additionally, localStorage persistence requires centralized state management.

---

## Implementation Steps

### 10. Create State Type

**File**: `src/models/color-format-state.ts`

Create a discriminated union type following the existing pattern:

```typescript
export type ColorFormatState =
  | { isLoading: true }
  | { isLoading: false; value: ColorFormat };

export type ColorFormat = "hex" | "oklch";
```

### 20. Add Storage Key

**File**: `src/models/storage/storage.ts`

Add a new storage key:

```typescript
export const storageKeys = {
  theme: `${storagePrefix}theme`,
  showEdgeShades: `${storagePrefix}showEdgeShades`,
  palettes: `${storagePrefix}palettes`,
  colorFormat: `${storagePrefix}colorFormat`,  // Add this
} as const;
```

### 30. Create Color Format Context Provider

**File**: `src/contexts/color-format/color-format-context.tsx`

Follow the `show-edge-shades` pattern:

- Create signal with initial `{ isLoading: true }` state
- Load from localStorage on mount
- Persist to localStorage on change
- Provide `colorFormat`, `setColorFormat`, `resetColorFormat` in context value

### 35. Create Color Format Hook

**File**: `src/contexts/color-format/use-color-format.ts`

Export `useColorFormat()` hook that throws if used outside provider.

### 40. Register Provider

**File**: `src/app.tsx`

Add `ColorFormatProvider` to the provider hierarchy:

```tsx
<ThemeProvider>
  <ShowEdgeShadesProvider>
    <ColorFormatProvider>        {/* Add here */}
      <ColorsProvider>
        <SettingsProvider>
          <EditModeProvider>
            ...
          </EditModeProvider>
        </SettingsProvider>
      </ColorsProvider>
    </ColorFormatProvider>
  </ShowEdgeShadesProvider>
</ThemeProvider>
```

### 50. Create Format Selector Component

**File**: `src/components/color-format-select.tsx`

Create a dropdown select component (scales to future format options):

```tsx
import type { ColorFormat } from "../models/color-format-state";
import { useColorFormat } from "../contexts/color-format/use-color-format";

const formatLabels: Record<ColorFormat, string> = {
  hex: "HEX",
  oklch: "OKLCH",
};

export function ColorFormatSelect() {
  const { colorFormat, setColorFormat } = useColorFormat();

  const handleChange = (e: Event) => {
    const target = e.target as HTMLSelectElement;
    setColorFormat(target.value as ColorFormat);
  };

  return (
    <select
      value={colorFormat().isLoading ? "hex" : colorFormat().value}
      disabled={colorFormat().isLoading}
      onChange={handleChange}
      class="px-2 py-1.5 text-sm rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 ..."
    >
      {Object.entries(formatLabels).map(([value, label]) => (
        <option value={value}>{label}</option>
      ))}
    </select>
  );
}
```

### 60. Place Selector in Header

**File**: `src/components/header.tsx`

Integrate `ColorFormatSelect` into the header, positioned before the Edit button:

```tsx
import { ColorFormatSelect } from "./color-format-select";

export function Header() {
  // ...
  return (
    <header class="flex items-center justify-between p-6">
      <h1 class="...">Indexed Palette Builder</h1>

      <div class="relative flex items-center gap-2" ref={setSettingsContainerRef}>
        <ColorFormatSelect />          {/* Add here */}
        <Button onClick={toggleEditMode} class="...">
          {isEditMode() ? "Done" : "Edit"}
        </Button>
        <Button onClick={toggleSettings} class="..." aria-label="Settings">
          <Settings size={20} />
        </Button>
        <SettingsPopup />
      </div>
    </header>
  );
}

### 70. Update Settings Reset

**File**: `src/components/settings-popup.tsx`

Add `resetColorFormat()` to the `handleResetSettings` function so "Reset all data" also resets the format preference.

## Files Created

| File | Purpose | Status |
|------|---------|--------|
| `src/models/color-format-state.ts` | State and format type definitions | Done |
| `src/contexts/color-format/color-format-context.tsx` | Context provider with localStorage | Done |
| `src/contexts/color-format/use-color-format.ts` | Custom hook | Done |
| `src/components/color-format-select.tsx` | Dropdown selector component | Done |

## Files Modified

| File | Change | Status |
|------|--------|--------|
| `src/models/storage/storage.ts` | Add `colorFormat` storage key | Done |
| `src/app.tsx` | Add `ColorFormatProvider` to hierarchy | Done |
| `src/components/header.tsx` | Add `ColorFormatSelect` component | Done |
| `src/components/settings-popup.tsx` | Add reset logic for color format | Done |

## Verification

After implementation:

1. Verify the format dropdown appears in the header (before Edit button)
2. Select OKLCH from dropdown
3. Reload the page - verify OKLCH remains selected (persisted)
4. Open settings and click "Reset all data" - verify format resets to HEX

---

## Apply Color Format to Output

### Objective

Use the `colorFormat` setting to change the displayed color values in:
1. Swatch tooltips (color-palette.tsx)
2. CSS variable output (css-export.tsx)

### Prerequisites

- OKLCH formatting utility function to convert `Oklch` type to CSS string

### Implementation Steps

#### 80. Create OKLCH Formatter Utility

**File**: `src/utils/format-oklch.ts`

Convert `Oklch` type from culori to CSS string format:

```typescript
import type { Oklch } from "culori";

export function formatOklch(color: Oklch): string {
  // Output: oklch(62.8% 0.258 29.2)
}
```

#### 90. Update Color Palette Tooltips

**File**: `src/components/color-palette.tsx`

- Import `useColorFormat` hook
- Format tooltip text based on selected format
- When HEX: show `${shade}: ${item.hex}`
- When OKLCH: show `${shade}: ${formatOklch(item.oklch)}`

#### 100. Update CSS Export Output

**File**: `src/components/css-export.tsx`

- Import `useColorFormat` hook
- Generate CSS variables in selected format
- When HEX: `--color-{name}-{shade}: #ff0000;`
- When OKLCH: `--color-{name}-{shade}: oklch(62.8% 0.258 29.2);`

### Files to Create

| File | Purpose |
|------|---------|
| `src/utils/format-oklch.ts` | OKLCH to CSS string formatter |

### Files to Modify

| File | Change |
|------|--------|
| `src/components/color-palette.tsx` | Use color format for tooltips |
| `src/components/css-export.tsx` | Use color format for CSS output |

---

## Big.js Precision Refactor

### Problem

Floating-point artifacts appear in OKLCH output:

```
--color-oasis-600: oklch(68.09999999999999% 0.162 75.834);
--color-oasis-50: oklch(98.7% 0.022344827586206897 75.834);
```

Given input: `oklch(68.1% 0.162 75.834)`

### Root Cause

1. User inputs `oklch(68.1% 0.162 75.834)` as a string
2. **culori** parses this into JavaScript `number` types
3. JavaScript IEEE 754 floating-point represents `0.681` as `0.6809999999999999...`
4. By the time our code receives the `Oklch` object, the precision error is already baked in
5. Big.js can only preserve precision for operations **we perform** - it cannot fix errors already present in input numbers

### Current State (Partial Fix)

The following files now use Big.js for internal calculations:

| File | Status |
|------|--------|
| `src/models/color/calc-blend-ratio.ts` | Returns `Big`, uses `Big()` for divisions |
| `src/models/color/calc-color.ts` | Accepts `Big` chromaScale, uses `Big()` for arithmetic |
| `src/models/color/generate-palette.ts` | Creates chromaScale as `Big` |
| `src/utils/format-oklch.ts` | Uses `Big()` for l * 100 multiplication |

**Problem**: The input `Oklch` values from culori are already JavaScript numbers with floating-point artifacts.

### Solution: Integer-Anchored String Extraction

Trust culori completely for syntax validation and parsing. Use the integer part of parsed values as anchors to locate and extract precise string representations from the original input.

#### Principle

In computational science, the integer part of floating-point numbers generally remains intact. This serves as a reliable reference point to align culori's parsed result with the original string.

#### Algorithm

1. **culori parses** input string, returns `Oklch` with JavaScript numbers
2. **Extract integer part** of each value as anchor (e.g., `0.6809999999999999` * 100 â†’ `68`)
3. **Search original string** for numeric value starting with that integer
4. **Extract precise string** from original input
5. **Convert to Big.js** preserving exact precision

#### Example

Input: `oklch(68.1% 0.162 75.834)`

| Component | culori result | Integer anchor | String match | Big.js value |
|-----------|---------------|----------------|--------------|--------------|
| L | `0.6809999999999999` | `68` | `68.1%` | `Big("68.1").div(100)` |
| C | `0.162` | `0` | `0.162` | `Big("0.162")` |
| H | `75.834` | `75` | `75.834` | `Big("75.834")` |

#### 110. Create OklchBig Type

**File**: `src/models/color/oklch-big.ts`

```typescript
import type Big from "big.js";

export type OklchBig = Readonly<{
  mode: "oklch";
  l: Big;       // 0-1 range (normalized)
  c: Big;       // chroma
  h: Big;       // hue in degrees
  alpha?: Big;  // optional alpha
}>;
```

#### 120. Create Integer-Anchored Extractor

**File**: `src/models/color/extract-precise-value.ts`

Extract precise string value from original input using integer anchor:

```typescript
import Big from "big.js";

export function extractPreciseValue(
  input: string,
  culoriValue: number,
  isPercentage: boolean
): Big {
  // 1. Calculate integer anchor
  const displayValue = isPercentage ? culoriValue * 100 : culoriValue;
  const integerPart = Math.trunc(displayValue);

  // 2. Search for numeric string starting with integer anchor
  // 3. Extract full numeric string (including decimals)
  // 4. Handle suffix (%, deg, rad, grad, turn)
  // 5. Return Big() with appropriate normalization
}
```

#### 130. Create Precision-Aware OKLCH Parser

**File**: `src/models/color/parse-oklch-with-precision.ts`

```typescript
import { parse, type Oklch } from "culori";
import { extractPreciseValue } from "./extract-precise-value";
import type { OklchBig } from "./oklch-big";

export function parseOklchWithPrecision(input: string): OklchBig | null {
  // Step 1: Validate with culori
  const parsed = parse(input);
  if (!parsed || parsed.mode !== "oklch") {
    return null;
  }
  const oklch = parsed as Oklch;

  // Step 2: Extract precise values using integer anchors
  const l = extractPreciseValue(input, oklch.l, /* detect from string */);
  const c = extractPreciseValue(input, oklch.c, false);
  const h = extractPreciseValue(input, oklch.h ?? 0, false);

  return { mode: "oklch", l, c, h };
}
```

#### 140. Update Calculation Chain

Modify calculation functions to work with `OklchBig`:

- `generate-palette-from-oklch-string.ts`: Use `parseOklchWithPrecision()`
- `generate-palette.ts`: Accept `OklchBig` input
- `calc-color.ts`: Work entirely with `Big` values

#### 150. Update Format Output

**File**: `src/utils/format-oklch.ts`

```typescript
import type { OklchBig } from "../models/color/oklch-big";

export function formatOklch(color: OklchBig): string {
  const l = color.l.times(100).toString();
  const c = color.c.toString();
  const h = color.h.toString();
  return `oklch(${l}% ${c} ${h})`;
}
```

### Files to Create

| File | Purpose |
|------|---------|
| `src/models/color/oklch-big.ts` | Big.js-based Oklch type definition |
| `src/models/color/extract-precise-value.ts` | Integer-anchored string extraction |
| `src/models/color/parse-oklch-with-precision.ts` | Two-step parser: culori + precise extraction |

### Files to Modify

| File | Change |
|------|--------|
| `src/models/color/generate-palette-from-oklch-string.ts` | Use `parseOklchWithPrecision()` |
| `src/models/color/generate-palette.ts` | Accept `OklchBig` input |
| `src/models/color/calc-color.ts` | Work with `OklchBig` throughout |
| `src/utils/format-oklch.ts` | Accept `OklchBig` for formatting |

### Verification

After implementation:

1. Input `oklch(68.1% 0.162 75.834)`
2. Verify shade 600 output: `oklch(68.1% 0.162 75.834)` (exact match)
3. Input `oklch(0.681 0.162 215.221deg)`
4. Verify decimal L and hue with unit handled correctly
5. Verify calculated shades use Big.js throughout (no floating-point artifacts)

---

## Future Scope (Out of Current Plan)

- Additional formats: rgb, rgba, hexa
